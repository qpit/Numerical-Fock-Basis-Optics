# -*- coding: utf-8 -*-
"""
Created on Fri Aug 14 09:35:13 2020
List of functions used in quantum optics circuits

Version 1

TODO:
    Add more documentation
@author: Anders Bjerrum
"""

## Imported packages
import numpy as np
from operator import add
from scipy.sparse import csr_matrix, csc_matrix
import scipy.sparse as s
from scipy.special import binom
from scipy.sparse import linalg
import math
import scipy.special as ss
import matplotlib.pyplot as plt
from copy import deepcopy
import Timer
from mpmath import *
import cmath


## State class
class state:
#Common base class for all states
    def __init__(self,modes,dim,Fock):
        self.modes = modes
        self.dim = {}
        self.assignDim(dim)
        self.matrix = csc_matrix(1)
        self.Fock = Fock
        self.Prob = 1
        
        self.basis = {}
        self.constructBasis()
        self.GS()

    
    def assignDim(self,dim):
        for j in range(0,len(self.modes)):
            self.dim[self.modes[j]] = dim[j]
    
    def constructBasis(self):
        for mode in self.modes:
            self.basis[mode]=np.identity(self.dim[mode])
    
    def GS(self):
        gs = 1
        for j in range(0,len(self.modes)):
            gs = kron((gs,self.basis[self.modes[j]][:,[0]]))
        self.matrix = kron((gs,herm(gs)))
        
    def rename(self,x,xnew):
        self.dim[xnew] = self.dim.pop(x)
        self.basis[xnew] = self.basis.pop(x)
        ind = self.modes.index(x)
        self.modes[ind] = xnew

        
    def operator(self,O):
        # Evolution under operator O
        self.matrix = O.dot(self.matrix).dot(herm(O))
        
    def channel(self,L):
        # Evolution by the channel defined by the set of Krauss operators L
        M = 0
        for O in L:
            temp = O.dot(self.matrix.dot(herm(O)))
            M = M + temp
        self.matrix = M
        
    def mixed(self,O,P):
        # Prepares a mixed state generated by the operators in the list O.
        # The relative probabilities are stored in the list P
        M = 0
        for i in range(0,len(O)):
            M = P[i]*O[i].dot(self.matrix.dot(herm(O[i]))) + M
        self.matrix = M

    
    def attach(self,state):
        # Attaches a state object to this state by expanding the density matix and adding mode designations
        cnt = 0
        for key in self.modes:
            self.dim[key+'_0'] = self.dim.pop(key)
            self.basis[key+'_0'] = self.basis.pop(key)
            self.modes[cnt] = self.modes[cnt]+'_0'
            cnt = cnt + 1
        
        cnt = 0
        for key in state.modes:
            self.dim[key+'_1'] = state.dim.pop(key)
            self.basis[key+'_1'] = state.basis.pop(key)
            self.modes.append(state.modes[cnt]+'_1')
            cnt = cnt + 1
            
        self.matrix = s.kron(self.matrix,state.matrix)

        

    def partialTrace(self,t):
        # t: List containing the modes to be traced
        # modes: List of all modes in the system
        # Calculates the partial trace of the state wrt. the modes contained in t
        tempModes = self.modes[:]
        for j in range(0,len(tempModes)):
            x = tempModes[j]
            if x in t:
                N = self.dim[x]
                M = 0
                for i in range(0,N):
                    M = M + self.getMatrixElement([[i,i]],x)
                self.matrix = M
                self.modes.remove(x)
                self.basis.pop(x)
                self.dim.pop(x)
                
    def covarianceMatrix(self):
        # Computes and returns the covariance matrix of the state
        N = len(self.modes)
        C = np.zeros((2*N,2*N),dtype='complex')
        for i in range(0,2*N):
            for j in range(0,2*N):
                aRi = O('aR',self,x=self.modes[math.floor(i/2)])
                aLi = O('aL',self,x=self.modes[math.floor(i/2)])
                
                aRj = O('aR',self,x=self.modes[math.floor(j/2)])
                aLj = O('aL',self,x=self.modes[math.floor(j/2)])
                
                if i%2 == 0:
                    Xi = aRi + aLi
                else:
                    Xi = 1j*(aRi - aLi)
                    
                if j%2 == 0:
                    Xj = aRj + aLj
                else:
                    Xj = 1j*(aRj - aLj)
                
                C[i,j] = 0.5*(expectance(self,Xi.dot(Xj)+Xj.dot(Xi)) - 2*expectance(self,Xi)*expectance(self,Xj))
        return C

        
            
    def getPhotonDist(self,x):
        # x: List of modes
        # Retrieves the joint photon distribution of the modes contained in the list x.
        # Faster than getPhotonDist
        stateCopy = deepcopy(self)
        for mode in self.modes:
            if mode not in x:
                stateCopy.partialTrace(mode)
        M = stateCopy.matrix.diagonal()
        D = np.zeros(len(x))
        for j in range(0,len(x)):
            D[j] = self.dim[x[j]]
        M = M.reshape(D.astype(int))
        return np.real(M)
            
            
    def projectState(self,nm,x):
        self.matrix = self.getMatrixElement(nm,x)
        for mode in x:
            self.basis.pop(mode)
            self.dim.pop(mode)
            self.modes.remove(mode)
            
            
    def measurement(self,nm,x,U=False):
        # Performs a non-destructive measurement and returns the density matrix.
        # If U is not false (default) then feedforward with operator U is applied.
        # nm: Basis states to project in to. Eg. [1,2] would project mode 1 and mode 2
        # into |1><1| and |2><2| respectively.
        # x: List of modes to project
        # U: Feedforward operator
        p = 1
        for i in range(0,len(x)):
            c = nm[i]
            p = np.dot(p,projectFock(self,c,c,x[i]))
        M = p.dot(self.matrix).dot(herm(p))
        if U is not False:
            M = U.dot(M).dot(herm(U))
        return M
        
    
    def getMatrixElement(self,nm,x):
        # Retrives the matrix element n,m of mode x.
        right = 1
        left = 1
        for mode in self.modes:
            if mode in x:
                index = x.index(mode)
                c = nm[index]
                n = c[0]
                m = c[1]
                ket = np.zeros(self.dim[mode])
                ket[m] = 1
                bra = np.zeros(self.dim[mode])
                bra[n] = 1
                right = kron((right,csc_matrix(ket).transpose()))
                left = kron((left,csc_matrix(bra)))
            else:
                right = kron((right,I(self,mode)))
                left = kron((left,I(self,mode)))
        return left.dot(self.matrix).dot(right)
    
    
    def addMode(self,x,d):
        # x: name of mode
        # d: Dimension of mode
        self.modes.append(x)
        self.dim[x] = d
        self.constructBasis()
        gs=self.basis[x][:,[0]]
        gsM = kron((gs,herm(gs)))
        self.matrix = kron((self.matrix,gsM))
        
    def normalize(self):
        norm = self.norm()
        self.Prob = norm
        self.matrix = self.matrix/norm
        
    def norm(self):
        return np.real(np.array(self.matrix.diagonal()).sum())
        
    def changeDim(self,x,N):
        # x: Mode
        # N: Dimension to change to.
        # Changes the dimension of mode x. This effectively projects the state into
        # a smaller or larger Hilbert space, potentially changing the normalization.
        NOld = self.dim[x]
        D = np.eye(N,NOld)
        D = csc_matrix(D)
        D = O(D,self,x,custom=True)
        self.operator(D)
        self.dim[x] = N
        self.basis[x] = np.identity(N)
        
    def addState(self,x,d,rho):
        # x: Modes
        # d: Dimensions of x's
        # rho: Density matrix for x
        # Adds the state rho, containg modes x of dimensions d to the density matrix
        for i in range(0,len(x)):
            self.modes.append(x[i])
            self.dim[x[i]] = d[i]
        self.constructBasis()
        self.matrix = kron((self.matrix,rho))
   
## Prepare state

def TMSV(state,x,xi,N):
    # Attaches a TMSV to the state object contained in state. The name of the two modes 
    # is contained in x = ['x1','x2']. xi is the squeezing.
    # state: State object
    # x: List of strings
    # xi: degree of squeezing
    # N: Dimension of modes
    state.addMode(x[0],N)
    state.addMode(x[1],N)
    phi = cmath.phase(xi)
    r = abs(xi)
    L = O('I',state,x[0]).dot(O('I',state,x[1]))
    ket = 1
    for k in range(1,N):
        ket = (O('aR',state,x[0]).dot(O('aR',state,x[1]))*(-1)*np.exp(1j*phi)*(math.tanh(r))/k).dot(ket)
        L = L + ket
    L = L/math.cosh(r)
    state.operator(L)
        
        
## Elementary operations
# Raising operator
def aR(state,M):
    # M: Mode to act on
    N = state.basis[M].shape[0]
    aR = np.roll(np.sqrt(np.diag(range(1,N+1))),1,axis=0)
    aR[0,-1] = 0
    return csc_matrix(aR)

# Lowering operator
def aL(state,M):
    N = state.basis[M].shape[0]
    aL = np.roll(np.sqrt(np.diag(range(0,N))),-1,axis=0)
    aL[-1,0] = 0
    return csc_matrix(aL)

# Number operator
def n(state,M):
    N = state.basis[M].shape[0]
    
    aL = np.roll(np.sqrt(np.diag(range(0,N))),-1,axis=0)
    aL[-1,0] = 0
    
    aR = np.roll(np.sqrt(np.diag(range(1,N+1))),1,axis=0)
    aR[0,-1] = 0
    
    return csc_matrix(aR.dot(aL))

# Identity operator
def I(state,M):
    return csc_matrix(state.basis[M])

def getFock(self,n,r=False):
        V = 1
        if r == True:
            for k in n:
                v = np.zeros(self.Fock)
                v[int(k)] = math.sqrt(math.factorial(int(k)))
                V = np.kron(V,v)
        else:
            for k in n:
                v = np.zeros(self.Fock)
                v[int(k)] = 1
                V = np.kron(V,v)
        return csc_matrix(V).transpose()


def O(O,state,x=None,custom=False):
    # O: Operator. String specifying a pre-programmed operator if custom=False, 
    #    If custom=True, the operator (Matrix) contained in O is used.
    # m: Mode to be acted upon
    # modes: List of all modes in the system
    # Constructs an operator acting on the mode listed in x.
    U = 1
    if custom:
        for i in range(0,len(state.modes)):
            if state.modes[i] == x:
                U = kron((U,O))
            else:
                U = kron((U,I(state,state.modes[i])))
        return U
                
    if O == 'aR':
        for i in range(0,len(state.modes)):
            if state.modes[i] == x:
                U = kron((U,aR(state,x)))
            else:
                U = kron((U,I(state,state.modes[i])))
            
    elif O == 'aL':
        for i in range(0,len(state.modes)):
            if state.modes[i] == x:
                U = kron((U,aL(state,x)))
            else:
                U = kron((U,I(state,state.modes[i])))
                             
    elif O == 'I':
        for i in range(0,len(state.modes)):
            U = kron((U,I(state,state.modes[i])))
    
    elif O == 'n':
        for i in range(0,len(state.modes)):
            if state.modes[i] == x:
                U = kron((U,n(state,x)))
            else:
                U = kron((U,I(state,state.modes[i])))
    return U

def projectFock(state,k,b,x):
    # Creates a projector |k><b|
    # state: State object
    # k: Resulting ket
    # b: Resulting bra
    # x: Mode to act on
    O = 1
    for mode in state.modes:
        if mode == x:
            bra = np.zeros(state.dim[mode])
            bra[b] = 1
            ket = np.zeros(state.dim[mode])
            ket[k] = 1
            
            ket = csc_matrix(ket).transpose()
            bra = csc_matrix(np.conj(bra))
            
            P = kron((ket,bra))
            O = kron((O,P))
        else:
            O = kron((O,I(state,mode)))
    return O

def freeRotation(state,x,v):
    # Free space rotation of mode x by the angle v
    H = -1j*v*O('n',state,x)
    H = csc_matrix(H)
    U = s.linalg.expm(H)
    return U

def BS(state,x,t):
    # Beam splitter operator
    M = 1j/2*t*(O('aR',state,x[0]).dot(O('aL',state,x[1]))+O('aL',state,x[0]).dot(O('aR',state,x[1])))
    M = csc_matrix(M)
    U = s.linalg.expm(M)
    return U

def BS2(state,x,t):
    # Beam splitter operator
    M = 1/2*t*(O('aR',state,x[0]).dot(O('aL',state,x[1]))-O('aL',state,x[0]).dot(O('aR',state,x[1])))
    M = csc_matrix(M)
    U = s.linalg.expm(M)
    return U

def TMS(state,x,xi):
    # Two-mode squeezing operator
    M = np.conj(xi)*O('aL',state,x[0]).dot(O('aL',state,x[1]))-xi*O('aR',state,x[0]).dot(O('aR',state,x[1]))
    M = csc_matrix(M)
    U = s.linalg.expm(M)
    return U

def D(state,x,b):
    # Displacement operator
    M = b*O('aR',state,x[0])-np.conj(b)*O('aL',state,x[0])
    M = csc_matrix(M)
    U = s.linalg.expm(M)
    return U

def dualHomodyne(state,x,gamma):
    # Dual homodyne measurement projector assuming feedforward (no displacement needed). C is the input field
    #(to be teleported)
    d1 = state.dim[x[0]]
    d2 = state.dim[x[1]]
    P = 0
    for i in range(0,np.min([d1,d2])):
        for j in range(0,np.min([d1,d2])):
            p1 = projectFock(state,j,i,x[0])
            p2 = projectFock(state,j,i,x[1])
            Dp = D(state,x[0],gamma)
            P = P + Dp.dot(p1).dot(p2).dot(herm(Dp))
        
    P = P/np.pi
        
    return P
        

def onOff(state,x,click,eta,v):
    # On/Off detector. If Click is true, returns the projector P1, projecting x
    # on to any state consistent with the detection of one or more photons. If Click is false, the
    # instead P2 is returned corresponding to no photons detected. P1 will
    # project onto any photon state with detection probability eta, and onto vacuum
    # with the dark count probability D. Likewise P2 will project onto vacuum with
    # vacuum detection probability (1-D) and onto any photon state with detection
    # error probability (1-eta).
    
    D = np.exp(-v)
    P = 0
    for j in range(0,state.dim[x]):
        P = P + D*(1-eta)**j*projectFock(state,j,j,x)

    if click == True:
        I = 0
        for j in range(0,state.dim[x]):
            I = I + projectFock(state,j,j,x)
        P = I - P
    
    return P

def SPD(state,x,click):
    if click == True:
        P = projectFock(state,1,1,x)
    elif click == False:
        P = projectFock(state,0,0,x)
    return P


def QS(state,g,x):
    # Generates a quantum scissor operator.
    # state: state
    # g: Gain generated by the scissor
    # x: Mode to act on
    return math.sqrt(1/2/(g**2+1))*(projectFock(state,0,0,x)+g*projectFock(state,1,1,x))

def NLA(state,g,x):
    # Generates a NLA operator.
    # state: state
    # g: Gain generated by the scissor
    # x: Mode to act on
    return math.sqrt(1/2/(g**2+1))*(projectFock(state,0,0,x)+g*projectFock(state,1,1,x))

def CNOT_Larmor(state,t,c):
    # Flips a two-state mode conditional on the state of another two-state mode.
    # State: State
    # t: Target mode
    # c: Control mode
    
    sx = pauliX(state,t)
    
    y = projectFock(state,1,1,c)
    n = projectFock(state,0,0,c)
    
    U = 1j*sx.dot(n) + y
    
    return U

def CPF(state,t,c):
    # Controlled phase flip, dependent on cavity state. See 
    # 'Scalable Photonic Quantum Computation through Cavity-Assisted Interactions'
    # State: State
    # t: Target mode
    # c: Control mode
    
    pf = 0
    for j in range(0,state.dim[t]):
        pf = pf + (-1)**j*projectFock(state,j,j,t)
    
    y = projectFock(state,1,1,c)
    n = projectFock(state,0,0,c)
    
    CPF = pf.dot(n) + y
    
    return CPF

def FockWave(q,n):
    return np.exp(-q**2/2)*ss.hermite(n)(q)/np.sqrt(2**n*math.factorial(n)*np.sqrt(np.pi))

def homodyne(state,q,t):
    # Performs a q homodyne measurement of mode t, giving the quadrature q.
    # q: q quadrature value
    # t: Target mode
    M = 0
    for j in range(0,state.dim[t]):
        for k in range(0,state.dim[t]):
            M = M + FockWave(q,j)*FockWave(q,k)*state.getMatrixElement([[j,k]],[t])
    state.partialTrace(t)
    state.matrix = M
    
    return M
    

def pauliX(state,x):
    # Creates a Pauli x operator acting on mode x
    # x: Mode - string
    return projectFock(state,1,0,x) + projectFock(state,0,1,x)

def pauliY(state,x):
    # Creates a Pauli x operator acting on mode x
    # x: Mode - string
    return 1j*projectFock(state,1,0,x) - 1j*projectFock(state,0,1,x)

def pauliZ(state,x):
    # Creates a Pauli x operator acting on mode x
    # x: Mode - string
    return projectFock(state,0,0,x) - projectFock(state,1,1,x)

def hadamard(state,x):
    # Creates a Hadamard gate for mode x
    # x: mode - String
    return (pauliZ(state,x) + pauliX(state,x))/math.sqrt(2)


def Sq(state,x,xi):
    # Single-mode squeezing operator
    M = (np.conj(xi)*O('aL',state,x[0]).dot(O('aL',state,x[0]))-xi*O('aR',state,x[0]).dot(O('aR',state,x[0])))/2
    M = csc_matrix(M)
    U = s.linalg.expm(M)
    return U

def concurrence_TwoQubit(rho):
    sigmaY = np.array([[0,-1j],[1j,0]])
    sigmaY = np.kron(sigmaY,sigmaY)
    rhoTilde = np.dot(np.conjugate(rho),sigmaY)
    rhoTilde = np.dot(sigmaY,rhoTilde)
    M = np.dot(rho,rhoTilde)
    lmbds = np.linalg.eigvals(M)
    lmbds = np.flip(np.sort(np.sqrt(lmbds)))
    EigDiff = np.array([1,-1,-1,-1]).dot(lmbds)
    C = np.max([0,EigDiff])
    
    return np.real(C)

def EOF_TwoQubit(C):
    if C>0 and C<1:
        return -(1+math.sqrt(1-C**2))/2*math.log2((1+math.sqrt(1-C**2))/2)-(1-math.sqrt(1-C**2))/2*math.log2((1-math.sqrt(1-C**2))/2)
    elif C>=1:
        return 1
    else:
        return 0
    
def bellProjectors(state,bell,x1,x2):
    if bell == 'phi+':
        P = 1/2*(projectFock(state,[0],[0],x1).dot(projectFock(state,[0],[0],x2)) +
            projectFock(state,[1],[0],x1).dot(projectFock(state,[1],[0],x2)) +
            projectFock(state,[0],[1],x1).dot(projectFock(state,[0],[1],x2)) +
            projectFock(state,[1],[1],x1).dot(projectFock(state,[1],[1],x2)))
    elif bell == 'phi-':
        P = 1/2*(projectFock(state,[0],[0],x1).dot(projectFock(state,[0],[0],x2)) -
            projectFock(state,[1],[0],x1).dot(projectFock(state,[1],[0],x2)) -
            projectFock(state,[0],[1],x1).dot(projectFock(state,[0],[1],x2)) +
            projectFock(state,[1],[1],x1).dot(projectFock(state,[1],[1],x2)))
    elif bell == 'psi+':
        P = 1/2*(projectFock(state,[0],[0],x1).dot(projectFock(state,[1],[1],x2)) +
            projectFock(state,[1],[0],x1).dot(projectFock(state,[0],[1],x2)) +
            projectFock(state,[0],[1],x1).dot(projectFock(state,[1],[0],x2)) +
            projectFock(state,[1],[1],x1).dot(projectFock(state,[0],[0],x2)))
    elif bell == 'psi-':
        P = 1/2*(projectFock(state,[0],[0],x1).dot(projectFock(state,[1],[1],x2)) -
            projectFock(state,[1],[0],x1).dot(projectFock(state,[0],[1],x2)) -
            projectFock(state,[0],[1],x1).dot(projectFock(state,[1],[0],x2)) +
            projectFock(state,[1],[1],x1).dot(projectFock(state,[0],[0],x2)))
        
    return P
        

## Symplectic Transformations

def S_BS(state,m1,m2,R):
    # Beam splitter symplectic transform
    d = len(state.modes)
    U = np.identity(2*d)
    i1 = state.modes.index(m1)
    i2 = state.modes.index(m2)
    U[2*i1,2*i1] = math.sqrt(1-R)
    U[2*i1+1,2*i1+1] = math.sqrt(1-R)
    U[2*i2,2*i2] = math.sqrt(1-R)
    U[2*i2+1,2*i2+1] = math.sqrt(1-R)
    U[2*i1,2*i2] = -math.sqrt(R)
    U[2*i1+1,2*i2+1] = -math.sqrt(R)
    U[2*i2,2*i1] = math.sqrt(R)
    U[2*i2+1,2*i1+1] = math.sqrt(R)
    return U

def S_SQ(state,m1,R):
    # Single-mode squeezing symplectic transform
    d = len(state.modes)
    U = np.identity(2*d)
    i1 = state.modes.index(m1)
    U[2*i1,2*i1] = np.exp(-R)
    U[2*i1+1,2*i1+1] = np.exp(R)
    return U

def S_SQ2(state,m1,m2,R):
    # Two-mode squeezing symplectic transform
    d = len(state.modes)
    U = np.identity(2*d)
    i1 = state.modes.index(m1)
    i2 = state.modes.index(m2)
    
    U[2*i1,2*i1] = math.cosh(R)
    U[2*i1+1,2*i1+1] = math.cosh(R)
    U[2*i2,2*i2] = math.cosh(R)
    U[2*i2+1,2*i2+1] = math.cosh(R)
    
    U[2*i1,2*i2] = math.sinh(R)
    U[2*i1+1,2*i2+1] = -math.sinh(R)
    U[2*i2,2*i1] = math.sinh(R)
    U[2*i2+1,2*i1+1] = -math.sinh(R)
    
    return U

def S_R(state,m,v):
    # Rotate the phase of a given mode. Symplectic transform:
    d = len(state.modes)
    U = np.identity(2*d)
    U[2*i1,2*i1] = math.cos(v)
    U[2*i1+1,2*i1] = -math.sin(v)
    U[2*i1,2*i1+1] = math.sin(v)
    U[2*i1+1,2*i1+1] = math.cos(v)
    return U


### Bosonic channels
# Lossy channel
def lossyChannel(state,x,g,n):
    # Defines Krauss operators for the lossy channel. The expression is based off arXiv:1708.05010v3 (eq 1.4)
    # state: State to act on
    # x: mode to act on
    # g: Attenuation of channel
    # n: Number of Krauss operators to compute
    
    L = []
    M = math.log(1-g)*O('n',state,x)/2
    M = M.todense()
    M = csc_matrix(M)
    E = s.linalg.expm(M)
    L.append(E)
    for j in range(1,n):
        E = (math.sqrt(g/(1-g))*O('aL',state,x)/math.sqrt(j)).dot(E)
        L.append(E)
        
    #print('Max value of last Krauss Operator:',np.max(np.abs(E.todense())))
    return L



def vonNeumannEntropy(M):
    # Computes the von Neumann entropy of the matrix M
    # M: Matrix
    w, v = np.linalg.eig(M)
    rsum = 0
    for a in w:
        if a>0:
            rsum = rsum - a*np.log(a)

    return np.real(rsum)

def QMutualInformation(state,x):
    # Computes the mutual information between two modes
    # x: Two modes in a list eg. ['A','B']
    if len(x)!=2:
        print('More or less than two modes specified')
        return 'Error'

    stateCopy = deepcopy(state)
    for mode in state.modes:
        if mode not in x:
            stateCopy.partialTrace(mode)
    
    MAB = stateCopy.matrix.todense()
    SAB = vonNeumannEntropy(MAB)
    
    S = np.zeros(2)
    for i in range(0,len(x)):
        stateCopyCopy = deepcopy(stateCopy)
        stateCopyCopy.partialTrace(x[i])
        S[i] = vonNeumannEntropy(stateCopyCopy.matrix.todense())

    return np.sum(S) - SAB



def Entropy(state,x):
    # Computes the entropy of a subsystem
    # x: Two modes in a list eg. ['A','B']

    stateCopy = deepcopy(state)
    for mode in state.modes:
        if mode not in x:
            stateCopy.partialTrace(mode)
    
    MAB = stateCopy.matrix.todense()
    SAB = vonNeumannEntropy(MAB)
    
    return SAB


# ### State preparation


def sparseP(M,i):
    # M: Sparse matrix
    # i: Power
    # Calculates the i'th power of a sparse matrix M
    out = s.identity(M.shape[1])
    for j in range(0,i):
        out = out.dot(M)
    return out
        
def kron(t):
    # t: Tuple of sparse matrices for which to compute the kronecker product
    # Computes the Kronecker product of a tuple of sparse matrices
    prod = t[0]
    for j in range(1,len(t)):
        prod = s.kron(prod,t[j])
    return prod

def kronP(O,n):
    # O: Sparse matrix
    # n: Power
    # Computes the n'th kronecker product power of the sparse matrix O
    if n>0:
        prod = O
        for j in range(1,n):
            prod = s.kron(prod,O)
    else:
        prod = 1
    return prod



def Mproduct(t):
    # t: Tuple of sparse matrices
    # Computes the product of the sparse matrices in the tuple t
    prod = t[0]
    for j in range(1,len(t)):
        if isinstance(t[j],(int,float)):
            prod = prod*t[j]
        else:
            prod = prod.dot(t[j])
    return prod

def herm(U):
    # U: Sparse matrix
    # Computes the Hermitian conjugate of the sparse matrix U
    U = np.conjugate(U)
    U = np.transpose(U)
    return U


def dotP(a,b):
    # a: Sparse matrix
    # b: Sparse matrix
    # Computes the inner (dot) product of two sparse matrices. 
    # If the dimensions do not match, the outer product (kronecker) is compute instead.
    [ra,ca] = a.shape()
    [rb,cb] = b.shape()
    if rb == ca:
        return a.dot(b)
    else:
        return kron((a,b))

## Compute Beamsplitter eigenstates
def BS_eig_gen(T,N):
    # Computes the eigenstates of the beamsplitter. Specify the two quantum numbers
    # N and a to generate a particular eigenstate. 
    # T = (N-a)/2 & P = (N+a)/2 & N+a = even & |a|<=N &  N,a are integers.
    mp.dps = 60 # Works up to N = 400
    R = 2*N+4
    if R%2 != 0:
        R = R+1

    C = np.zeros(R)
    C[int(R/2)] = mpf('1')

    r = np.array([(math.sqrt(x),0) for x in range(1,int(R/2)+1)]).ravel()
    r = r*mpf('1')
    l = np.flip(r)
    r = np.roll(r,int(R/2))
    l = np.roll(l,-int(R/2)+1)

    for k in range(1,T+1):
        C = (np.roll(C*r,1) - np.roll(C*l,-1))/math.sqrt(2*k)
        r = np.roll(r,-1)
        l = np.roll(l,1)

    P = 1
    while True:
        logVec = np.array([(1,0) for x in range(0,int(P+T))]).ravel()
        leftPad = np.zeros(int(R/2)-P-T+1)
        rightPad = np.zeros(int(R/2)-P-T-1)
        logVec = np.concatenate((leftPad,logVec,rightPad)).astype(bool)
        vec = C[logVec].astype(float)
        yield vec
        
        C = (np.roll(C*r,1) + np.roll(C*l,-1))/math.sqrt(2*P)
        r = np.roll(r,-1)
        l = np.roll(l,1)
        P = P + 1
        
def BS_spectral_state(state,x,tol=0):
    out = 0
    
    dist = state.getPhotonDist2(x)
    M = np.flip(dist,axis=1)
    P = np.zeros(2*M.shape[0]-1)
    for k in range(0,2*M.shape[0]-1):
        P[k] = np.sum(np.diag(M,k-M.shape[0]+1))    
    P = np.flip(P)
    R = len(P)
    
    for T1 in range(0,R):
        bs1 = BS_eig_gen(T1,R)
        for P1 in range(0,R-T1):
            p1 = np.sum(P[P1+T1:-1])
            if p1<tol:
                return
            vec1 = next(bs)
            IP1 = state.matrix.dot(vec1)
            for T2 in range(T1,R):
                bs2 = BS_eig_gen(T2,R)
                for P2 in range(P1,R-T2):
                    p2 = np.sum(P[P2+T2:-1])
                    if p2<tol:
                        return
                    vec2 = next(bs)
                    IP2 = vec2.dot(IP1)
                    out = IP*kron((herm(vec1),vec2)) + out
                    
    out = out + herm(out)
    return out
                
def expectance(state,O):
    # O: Sparse matrix (Operator)
    # state: State object
    # Calculates the expectance value of operator O using the state
    M = state.matrix
    M = M.dot(O)
    return M.diagonal().sum()


        

def G(x):
    if x<=1:
        print('Negative symplectic eigenvalue')
        print(x)
        return 0
    else:
        return ((1+x)/2)*math.log((x+1)/2) - ((x-1)/2)*math.log((x-1)/2)

def keyRateG(cov):
    a = np.real(cov[0,0])
    b = np.real(cov[2,2])
    c = np.real(cov[0,2])
    I_AB = np.log2((1+a)/(1+a-c**2/(1+b)))
    print('IAB',I_AB)
    print(a)
    print(b)
    print(c)
    
    delta = a**2 + b**2 - 2*c**2
    D = np.linalg.det(cov)
    
    l1 = np.sqrt(0.5*(delta + np.sqrt(delta**2-4*D**2)))
    l2 = np.sqrt(0.5*(delta - np.sqrt(delta**2-4*D**2)))
    l3 = a-c**2/(b)
    print(l1)
    print(l2)
    
    S_AgB = G(l3/2-1/2)
    S_E = G(l1/2-1/2) + G(l2/2-1/2)
    
    print(S_E)
    print(S_AgB)
    
    Key = I_AB - S_E + S_AgB
    
    return Key

def symplecticEigenvalues(cov):
    l = cov.shape[0]
    a = np.array([[0,1],[-1,0]])
    O = np.kron(np.eye(int(l/2),dtype=int),a)
    M = 1j*O.dot(cov)
    w,v = np.linalg.eig(M)
    return w
    w = np.abs(w)
    return np.unique(np.round(w,5))

def CondCovariance(cov,rec):
    i1 = 2*rec
    i2 = 2*rec+2
    
    ii1 = 4-i2
    ii2 = 4-i1
    
    print(i1)
    print(i2)
    
    print(ii1)
    print(ii2)
    
    
    condCov = cov[i1:i2,i1:i2] - cov[2:4,0:2].dot(np.linalg.inv(cov[ii1:ii2,ii1:ii2])).dot(cov[0:2,2:4])

    return condCov



#def HolevoG(cov):
    

def photonDist(state,x):
    M = state.getPhotonDist2(x)
    plt.figure()
    plt.imshow(M)
    plt.colorbar()
    plt.show()

            
            
            
            

def Wmn_f(m,n,q,p):
    # Computes the Wigner function elements in the Fock basis
    out = (1/np.pi)*np.exp(-q**2-p**2)*(-1)**n*(q-1j*p)**(m-n)*np.sqrt(2**(m-n)*math.factorial(n)/math.factorial(m))*ss.genlaguerre(n, m-n)(2*q**2+2*p**2)
    return out
    


def WignerPlotter(state,q,p,x,c,dq,dp,Nm):
    zipped_lists = zip(x, c)
    sorted_zipped_lists = sorted(zipped_lists)
    x = [e for e,_ in sorted_zipped_lists]
    c = [e for _,e in sorted_zipped_lists]
    
    
    Wqp = 0
    Wqp2 = 0
    N = state.Fock
    Wmn = np.zeros((Nm,Nm,len(q),len(p)),dtype = 'complex64')
    Wmnq = np.zeros((Nm,Nm,len(q),1),dtype = 'complex64')
    Wmnp = np.zeros((Nm,Nm,1,len(p)),dtype = 'complex64')
    
    # for m in range(0,N):
    #     for n in range(0,N):
    #         if m>=n:
    #             Wmn[m,n,:,:] = Wmn_f(m,n,q,p)
    #         else:
    #             Wmn[m,n,:,:] = np.conj(Wmn_f(n,m,q,p))
    #         Wmnq[m,n,:,0] = Wmn[m,n,:,:].sum(0)
    #         Wmnp[m,n,0,:] = Wmn[m,n,:,:].sum(1)
    
    for k in range(1,Nm-1):
        Wmn[k,0,:,:] = Wmn_f(k,0,q,p)
        Wmn[k+1,1,:,:] = Wmn_f(k+1,1,q,p)
        for n in range(2,Nm-k):
            m = n + k
            Wmn[m,n,:,:] = Wmn[m-1,n-1,:,:]*(-1)*math.sqrt(n/m)*(n+m-1-2*(q**2+p**2))/n - (m-1)/n*Wmn[m-2,n-2,:,:]*1*math.sqrt((n*(n-1))/(m*(m-1)))    
    Wmn[Nm-1,0,:,:] = Wmn_f(Nm,0,q,p)
    Wmn = Wmn + np.conjugate(np.transpose(Wmn,axes=(1,0,2,3)))
    Wmn[0,0,:,:] = Wmn_f(0,0,q,p)
    Wmn[1,1,:,:] = Wmn_f(1,1,q,p)
    for n in range(2,Nm):
        m = n
        Wmn[m,n,:,:] = Wmn[m-1,n-1,:,:]*(-1)*math.sqrt(n/m)*(n+m-1-2*(q**2+p**2))/n - (m-1)/n*Wmn[m-2,n-2,:,:]*1*math.sqrt((n*(n-1))/(m*(m-1)))
    for n in range(0,Nm):
        for m in range(0,Nm):
            Wmnq[m,n,:,0] = Wmn[m,n,:,:].sum(0)*dp
            Wmnp[m,n,0,:] = Wmn[m,n,:,:].sum(1)*dq
        
    stateCopy = deepcopy(state)
    for mode in state.modes:
        if mode not in x:
            stateCopy.partialTrace(mode)
    
    
    M = stateCopy.matrix.todense()
    N = stateCopy.dim[x[0]]
    if len(x) == 1:
        for n in range(0,Nm):
            for m in range(0,Nm):
                ME = M[m,n]
                
                if np.all(ME==0):
                    continue
                Wqp = Wqp + np.tensordot(ME,Wmn[m,n,:,:],axes=0)
        W = np.squeeze(np.real(Wqp))
        
    elif len(x) == 2:
        for n in range(0,Nm):
            for m in range(0,Nm):
                ME = M[m*N:(m*N+Nm),n*N:(n*N+Nm)]
                #ME = stateCopy.getMatrixElement([[m,n]], mode).todense()
                if np.all(ME==0):
                    continue
                if 'q' in c[0]:
                    Wqp = Wqp + np.tensordot(ME,Wmnq[m,n,:,:],axes=0)
                elif 'p' in c[0]:
                    Wqp = Wqp + np.tensordot(ME,Wmnp[m,n,:,:],axes=0)
        
        for n in range(0,Nm):
            for m in range(0,Nm):    
                if 'q' in c[1]:
                    Wqp2 = Wqp2 + np.tensordot(Wmnq[m,n,:,:],Wqp[m,n,:,:],axes=0)
                elif 'p' in c[1]:
                    Wqp2 = Wqp2 + np.tensordot(Wmnp[m,n,:,:],Wqp[m,n,:,:],axes=0)
        W = np.squeeze(np.real(Wqp2))

    
    qdist = W.sum(0).transpose()*dp
    pdist = W.sum(1)*dq
    print(qdist.sum(0)*dq)
    print(pdist.sum(0)*dp)
    
    qrange = np.max(q)
    
    fig, axs = plt.subplots(2, 2,gridspec_kw={
                            'width_ratios': [2, 1],
                            'height_ratios': [1, 2]},constrained_layout=True)

    fig.suptitle('Wigner Distribution', fontsize=22)
    
    
    axs[1,1].plot(pdist, p[:,0])
    axs[0,0].plot(q[0,:],qdist)
   
    fig.delaxes(axs[0,1])
    fig.set_size_inches(9, 9)
    #fig.tight_layout()
    im = axs[1,0].imshow(W, cmap='viridis', interpolation='spline16',extent=[-qrange,qrange,-qrange,qrange])
    if len(x)==2:
        axs[1,0].set_xlabel('Mode '+x[0]+' - '+'Quadrature '+c[0])
        axs[1,0].set_ylabel('Mode '+x[1]+' - '+'Quadrature '+c[1])
    else:
        axs[1,0].set_xlabel('Quadrature q')
        axs[1,0].set_ylabel('Quadrature p')
    #cbaxes = fig.add_axes([0, -0.1, 0.6, 0.02])  # This is the position for the colorbar
    fig.colorbar(im, location='left',shrink=0.8)
    plt.show()
            
    return np.real(W),qdist,pdist

def secretKey(state,x,c,r,dq,dp,Nmax,beta):
    # Reconcilliator should be first in x
    MIAB = MI(state,x,c,dq,dp,Nmax)
    IE = Holevo(state,x[0],x[1],dq,Nmax)

    return beta*MIAB - IE
    
def Holevo(state,A,B,dq,Nmax):
    SAB = Entropy(state,[A,B])
    chi = SAB
    
    edge = 2*np.sqrt(Nmax+1/2)
    check = 0
    for xA in np.arange(-edge,edge,dq):
        M = conditionalDensityMatrix(state,A,B,xA)
        P = np.trace(M)*dq
        M = M/np.trace(M)
        SR = vonNeumannEntropy(M)
        chi = chi - P*SR       
        check = check + P
    #print('Norm: ',check)
    return chi

def FockWave(q,n):
    return np.exp(-q**2/2)*ss.hermite(n)(q)/np.sqrt(2**n*math.factorial(n)*np.sqrt(np.pi))

def conditionalDensityMatrix(state,A,B,xA):
    # Returns the density matrix of B conditioned on A measuring xA in quadrature q
    # state: State object
    # A: Measuring mode
    # B: Conditioned mode
    # xA: Measuring result of q measurement
    NB = state.dim[B]
    NA = state.dim[A]
    rho = np.zeros((NB,NB))
    for i in range(0,NB):
        for j in range(0,NB):
            nm = [[i,j]]
            M = state.getMatrixElement(nm,B)
            rsum = 0
            for k in range(0,NA):
                for l in range(0,NA):
                    rsum = rsum + M.todense()[k,l]*FockWave(xA,k)*FockWave(xA,l)
            rho[i,j] = np.real(rsum)
            
    return rho
    

def MI(state,x,c,dq,dp,Nmax):
    
    edge = 2*np.sqrt(Nmax+1/2)
    q = np.arange(-edge,edge,dq)
    p = -np.arange(-edge,edge,dp)
    qq,pp = np.meshgrid(q,p)
    [W,qdist,pdist] = Wigner(state,qq,pp,x,c,dq,dp,Nmax)
    qqdist,ppdist = np.meshgrid(qdist,pdist)
    print('The minimum of W is: ',np.min(W),' 10-12 + the negative value is added to make the log tractable.')
    
    W = W-np.min(W)+10**(-12)
    K = W/qqdist/ppdist
    
    intgrnd = W*np.log2(K)
    intgrl = np.sum(np.sum(intgrnd*dq*dp,1),0)
    
    return intgrl
    


def Wigner(state,q,p,x,c,dq,dp,Nm):

    
    zipped_lists = zip(x, c)
    sorted_zipped_lists = sorted(zipped_lists)
    x = [e for e,_ in sorted_zipped_lists]
    c = [e for _,e in sorted_zipped_lists]
    
    Wqp = 0
    Wqp2 = 0
    N = state.Fock
    Wmn = np.zeros((Nm,Nm,len(q),len(p)),dtype = 'complex64')
    Wmnq = np.zeros((Nm,Nm,len(q),1),dtype = 'complex64')
    Wmnp = np.zeros((Nm,Nm,1,len(p)),dtype = 'complex64')

    for k in range(1,Nm-1):
        Wmn[k,0,:,:] = Wmn_f(k,0,q,p)
        Wmn[k+1,1,:,:] = Wmn_f(k+1,1,q,p)
        for n in range(2,Nm-k):
            m = n + k
            Wmn[m,n,:,:] = Wmn[m-1,n-1,:,:]*(-1)*math.sqrt(n/m)*(n+m-1-2*(q**2+p**2))/n - (m-1)/n*Wmn[m-2,n-2,:,:]*1*math.sqrt((n*(n-1))/(m*(m-1)))    
    Wmn[Nm-1,0,:,:] = Wmn_f(Nm,0,q,p)
    Wmn = Wmn + np.conjugate(np.transpose(Wmn,axes=(1,0,2,3)))
    Wmn[0,0,:,:] = Wmn_f(0,0,q,p)
    Wmn[1,1,:,:] = Wmn_f(1,1,q,p)
    for n in range(2,Nm):
        m = n
        Wmn[m,n,:,:] = Wmn[m-1,n-1,:,:]*(-1)*math.sqrt(n/m)*(n+m-1-2*(q**2+p**2))/n - (m-1)/n*Wmn[m-2,n-2,:,:]*1*math.sqrt((n*(n-1))/(m*(m-1)))
    for n in range(0,Nm):
        for m in range(0,Nm):
            Wmnq[m,n,:,0] = Wmn[m,n,:,:].sum(0)*dp
            Wmnp[m,n,0,:] = Wmn[m,n,:,:].sum(1)*dq
        
    stateCopy = deepcopy(state)
    for mode in state.modes:
        if mode not in x:
            stateCopy.partialTrace(mode)
    
    
    M = stateCopy.matrix.todense()
    N = stateCopy.dim[x[0]]
    if len(x) == 1:
        for n in range(0,Nm):
            for m in range(0,Nm):
                ME = M[m,n]
                
                if np.all(ME==0):
                    continue
                Wqp = Wqp + np.tensordot(ME,Wmn[m,n,:,:],axes=0)
        W = np.squeeze(np.real(Wqp))
        
    elif len(x) == 2:
        for n in range(0,Nm):
            for m in range(0,Nm):
                ME = M[m*N:(m*N+Nm),n*N:(n*N+Nm)]
                #ME = stateCopy.getMatrixElement([[m,n]], mode).todense()
                if np.all(ME==0):
                    continue
                if 'q' in c[0]:
                    Wqp = Wqp + np.tensordot(ME,Wmnq[m,n,:,:],axes=0)
                elif 'p' in c[0]:
                    Wqp = Wqp + np.tensordot(ME,Wmnp[m,n,:,:],axes=0)
        
        for n in range(0,Nm):
            for m in range(0,Nm):    
                if 'q' in c[1]:
                    Wqp2 = Wqp2 + np.tensordot(Wmnq[m,n,:,:],Wqp[m,n,:,:],axes=0)
                elif 'p' in c[1]:
                    Wqp2 = Wqp2 + np.tensordot(Wmnp[m,n,:,:],Wqp[m,n,:,:],axes=0)
        W = np.squeeze(np.real(Wqp2))

    
    qdist = W.sum(0).transpose()*dp
    pdist = W.sum(1)*dq
    print(qdist.sum(0)*dq)
    print(pdist.sum(0)*dp)
    

    return np.real(W),qdist,pdist