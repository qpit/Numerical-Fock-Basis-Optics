# -*- coding: utf-8 -*-
"""
Created on Fri November 2022
Shortened list of functions used in quantum optics in the Fock basis.
Relevant for our paper "Quantum Repeater using Two-Mode Squeezed States and Atomic
 Noiseless Amplifiers"

Version 7

@author: Anders Jannik Ehlers Bjerrum
"""

## Imported packages
import numpy as np
from scipy.sparse import csc_matrix
import scipy.sparse as s
import math
import scipy.special as ss
from copy import deepcopy
import cmath


## State class
class state:
#Common base class for all states
    def __init__(self,modes,dim,Fock):
        self.modes = modes
        self.dim = {}
        self.assignDim(dim)
        self.matrix = csc_matrix(1)
        self.Fock = Fock
        self.Prob = 1
        
        self.basis = {}
        self.constructBasis()
        self.GS()

    
    def assignDim(self,dim):
        for j in range(0,len(self.modes)):
            self.dim[self.modes[j]] = dim[j]
    
    def constructBasis(self):
        for mode in self.modes:
            self.basis[mode]=np.identity(self.dim[mode])
    
    def GS(self):
        gs = 1
        for j in range(0,len(self.modes)):
            gs = kron((gs,self.basis[self.modes[j]][:,[0]]))
        self.matrix = kron((gs,herm(gs)))
        
    def rename(self,x,xnew):
        self.dim[xnew] = self.dim.pop(x)
        self.basis[xnew] = self.basis.pop(x)
        ind = self.modes.index(x)
        self.modes[ind] = xnew

        
    def operator(self,O):
        # Evolution under operator O
        self.matrix = O.dot(self.matrix).dot(herm(O))
        
    def channel(self,L):
        # Evolution by the channel defined by the set of Krauss operators L
        M = 0
        for O in L:
            temp = O.dot(self.matrix.dot(herm(O)))
            M = M + temp
        self.matrix = M
        
    def mixed(self,O,P):
        # Prepares a mixed state generated by the operators in the list O.
        # The relative probabilities are stored in the list P
        M = 0
        for i in range(0,len(O)):
            M = P[i]*O[i].dot(self.matrix.dot(herm(O[i]))) + M
        self.matrix = M

    
    def attach(self,state):
        # Attaches a state object to this state by expanding the density matix and adding mode designations
        cnt = 0
        for key in self.modes:
            self.dim[key+'_0'] = self.dim.pop(key)
            self.basis[key+'_0'] = self.basis.pop(key)
            self.modes[cnt] = self.modes[cnt]+'_0'
            cnt = cnt + 1
        
        cnt = 0
        for key in state.modes:
            self.dim[key+'_1'] = state.dim.pop(key)
            self.basis[key+'_1'] = state.basis.pop(key)
            self.modes.append(state.modes[cnt]+'_1')
            cnt = cnt + 1
            
        self.matrix = s.kron(self.matrix,state.matrix)

        

    def partialTrace(self,t):
        # t: List containing the modes to be traced
        # modes: List of all modes in the system
        # Calculates the partial trace of the state wrt. the modes contained in t
        tempModes = self.modes[:]
        for j in range(0,len(tempModes)):
            x = tempModes[j]
            if x in t:
                N = self.dim[x]
                M = 0
                for i in range(0,N):
                    M = M + self.getMatrixElement([[i,i]],x)
                self.matrix = M
                self.modes.remove(x)
                self.basis.pop(x)
                self.dim.pop(x)
                

    def projectState(self,nm,x):
        self.matrix = self.getMatrixElement(nm,x)
        for mode in x:
            self.basis.pop(mode)
            self.dim.pop(mode)
            self.modes.remove(mode)

    def getMatrixElement(self,nm,x):
        # Retrives the matrix element n,m of mode x.
        right = 1
        left = 1
        for mode in self.modes:
            if mode in x:
                index = x.index(mode)
                c = nm[index]
                n = c[0]
                m = c[1]
                ket = np.zeros(self.dim[mode])
                ket[m] = 1
                bra = np.zeros(self.dim[mode])
                bra[n] = 1
                right = kron((right,csc_matrix(ket).transpose()))
                left = kron((left,csc_matrix(bra)))
            else:
                right = kron((right,I(self,mode)))
                left = kron((left,I(self,mode)))
        return left.dot(self.matrix).dot(right)
    
    
    def addMode(self,x,d):
        # x: name of mode
        # d: Dimension of mode
        self.modes.append(x)
        self.dim[x] = d
        self.constructBasis()
        gs=self.basis[x][:,[0]]
        gsM = kron((gs,herm(gs)))
        self.matrix = kron((self.matrix,gsM))
        
    def normalize(self):
        norm = self.norm()
        self.Prob = norm
        self.matrix = self.matrix/norm
        
    def norm(self):
        return np.real(np.array(self.matrix.diagonal()).sum())
        
    def changeDim(self,x,N):
        # x: Mode
        # N: Dimension to change to.
        # Changes the dimension of mode x. This effectively projects the state into
        # a smaller or larger Hilbert space, potentially changing the normalization.
        NOld = self.dim[x]
        D = np.eye(N,NOld)
        D = csc_matrix(D)
        D = O(D,self,x,custom=True)
        self.operator(D)
        self.dim[x] = N
        self.basis[x] = np.identity(N)
        
    def addState(self,x,d,rho):
        # x: Modes
        # d: Dimensions of x's
        # rho: Density matrix for x
        # Adds the state rho, containg modes x of dimensions d to the density matrix
        for i in range(0,len(x)):
            self.modes.append(x[i])
            self.dim[x[i]] = d[i]
        self.constructBasis()
        self.matrix = kron((self.matrix,rho))
   
## Prepare state

def TMSV(state,x,xi,N):
    # Attaches a TMSV to the state object contained in state. The name of the two modes 
    # is contained in x = ['x1','x2']. xi is the squeezing.
    # state: State object
    # x: List of strings
    # xi: degree of squeezing
    # N: Dimension of modes
    state.addMode(x[0],N)
    state.addMode(x[1],N)
    phi = cmath.phase(xi)
    r = abs(xi)
    L = O('I',state,x[0]).dot(O('I',state,x[1]))
    ket = 1
    for k in range(1,N):
        ket = (O('aR',state,x[0]).dot(O('aR',state,x[1]))*(-1)*np.exp(1j*phi)*(math.tanh(r))/k).dot(ket)
        L = L + ket
    L = L/math.cosh(r)
    state.operator(L)
        
        
## Elementary operations
# Raising operator
def aR(state,M):
    # M: Mode to act on
    N = state.basis[M].shape[0]
    aR = np.roll(np.sqrt(np.diag(range(1,N+1))),1,axis=0)
    aR[0,-1] = 0
    return csc_matrix(aR)

# Lowering operator
def aL(state,M):
    N = state.basis[M].shape[0]
    aL = np.roll(np.sqrt(np.diag(range(0,N))),-1,axis=0)
    aL[-1,0] = 0
    return csc_matrix(aL)

# Number operator
def n(state,M):
    N = state.basis[M].shape[0]
    
    aL = np.roll(np.sqrt(np.diag(range(0,N))),-1,axis=0)
    aL[-1,0] = 0
    
    aR = np.roll(np.sqrt(np.diag(range(1,N+1))),1,axis=0)
    aR[0,-1] = 0
    
    return csc_matrix(aR.dot(aL))

# Identity operator
def I(state,M):
    return csc_matrix(state.basis[M])

def getFock(self,n,r=False):
        V = 1
        if r == True:
            for k in n:
                v = np.zeros(self.Fock)
                v[int(k)] = math.sqrt(math.factorial(int(k)))
                V = np.kron(V,v)
        else:
            for k in n:
                v = np.zeros(self.Fock)
                v[int(k)] = 1
                V = np.kron(V,v)
        return csc_matrix(V).transpose()


def O(O,state,x=None,custom=False):
    # O: Operator. String specifying a pre-programmed operator if custom=False, 
    #    If custom=True, the operator (Matrix) contained in O is used.
    # m: Mode to be acted upon
    # modes: List of all modes in the system
    # Constructs an operator acting on the mode listed in x.
    U = 1
    if custom:
        for i in range(0,len(state.modes)):
            if state.modes[i] == x:
                U = kron((U,O))
            else:
                U = kron((U,I(state,state.modes[i])))
        return U
                
    if O == 'aR':
        for i in range(0,len(state.modes)):
            if state.modes[i] == x:
                U = kron((U,aR(state,x)))
            else:
                U = kron((U,I(state,state.modes[i])))
            
    elif O == 'aL':
        for i in range(0,len(state.modes)):
            if state.modes[i] == x:
                U = kron((U,aL(state,x)))
            else:
                U = kron((U,I(state,state.modes[i])))
                             
    elif O == 'I':
        for i in range(0,len(state.modes)):
            U = kron((U,I(state,state.modes[i])))
    
    elif O == 'n':
        for i in range(0,len(state.modes)):
            if state.modes[i] == x:
                U = kron((U,n(state,x)))
            else:
                U = kron((U,I(state,state.modes[i])))
    return U

def projectFock(state,k,b,x):
    # Creates a projector |k><b|
    # state: State object
    # k: Resulting ket
    # b: Resulting bra
    # x: Mode to act on
    O = 1
    for mode in state.modes:
        if mode == x:
            bra = np.zeros(state.dim[mode])
            bra[b] = 1
            ket = np.zeros(state.dim[mode])
            ket[k] = 1
            
            ket = csc_matrix(ket).transpose()
            bra = csc_matrix(np.conj(bra))
            
            P = kron((ket,bra))
            O = kron((O,P))
        else:
            O = kron((O,I(state,mode)))
    return O

def freeRotation(state,x,v):
    # Free space rotation of mode x by the angle v
    H = -1j*v*O('n',state,x)
    H = csc_matrix(H)
    U = s.linalg.expm(H)
    return U

def BS(state,x,t):
    # Beam splitter operator
    M = 1j/2*t*(O('aR',state,x[0]).dot(O('aL',state,x[1]))+O('aL',state,x[0]).dot(O('aR',state,x[1])))
    M = csc_matrix(M)
    U = s.linalg.expm(M)
    return U

def BS2(state,x,t):
    # Beam splitter operator
    M = 1/2*t*(O('aR',state,x[0]).dot(O('aL',state,x[1]))-O('aL',state,x[0]).dot(O('aR',state,x[1])))
    M = csc_matrix(M)
    U = s.linalg.expm(M)
    return U

def TMS(state,x,xi):
    # Two-mode squeezing operator
    M = np.conj(xi)*O('aL',state,x[0]).dot(O('aL',state,x[1]))-xi*O('aR',state,x[0]).dot(O('aR',state,x[1]))
    M = csc_matrix(M)
    U = s.linalg.expm(M)
    return U

def D(state,x,b):
    # Displacement operator
    M = b*O('aR',state,x[0])-np.conj(b)*O('aL',state,x[0])
    M = csc_matrix(M)
    U = s.linalg.expm(M)
    return U

def onOff(state,x,click,eta,v):
    # On/Off detector. If Click is true, returns the projector P1, projecting x
    # on to any state consistent with the detection of one or more photons. If Click is false, the
    # instead P2 is returned corresponding to no photons detected. P1 will
    # project onto any photon state with detection probability eta, and onto vacuum
    # with the dark count probability D. Likewise P2 will project onto vacuum with
    # vacuum detection probability (1-D) and onto any photon state with detection
    # error probability (1-eta).
    
    D = np.exp(-v)
    P = 0
    for j in range(0,state.dim[x]):
        P = P + D*(1-eta)**j*projectFock(state,j,j,x)

    if click == True:
        I = 0
        for j in range(0,state.dim[x]):
            I = I + projectFock(state,j,j,x)
        P = I - P
    
    return P

def SPD(state,x,click):
    if click == True:
        P = projectFock(state,1,1,x)
    elif click == False:
        P = projectFock(state,0,0,x)
    return P


def FockWave(q,n):
    return np.exp(-q**2/2)*ss.hermite(n)(q)/np.sqrt(2**n*math.factorial(n)*np.sqrt(np.pi))

def homodyne(state,q,t):
    # Performs a q homodyne measurement of mode t, giving the quadrature q.
    # q: q quadrature value
    # t: Target mode
    M = 0
    for j in range(0,state.dim[t]):
        for k in range(0,state.dim[t]):
            M = M + FockWave(q,j)*FockWave(q,k)*state.getMatrixElement([[j,k]],[t])
    state.partialTrace(t)
    state.matrix = M
    
    return M
    

def pauliX(state,x):
    # Creates a Pauli x operator acting on mode x
    # x: Mode - string
    return projectFock(state,1,0,x) + projectFock(state,0,1,x)

def pauliY(state,x):
    # Creates a Pauli x operator acting on mode x
    # x: Mode - string
    return 1j*projectFock(state,1,0,x) - 1j*projectFock(state,0,1,x)

def pauliZ(state,x):
    # Creates a Pauli x operator acting on mode x
    # x: Mode - string
    return projectFock(state,0,0,x) - projectFock(state,1,1,x)

def hadamard(state,x):
    # Creates a Hadamard gate for mode x
    # x: mode - String
    return (pauliZ(state,x) + pauliX(state,x))/math.sqrt(2)

def Sq(state,x,xi):
    # Single-mode squeezing operator
    M = (np.conj(xi)*O('aL',state,x[0]).dot(O('aL',state,x[0]))-xi*O('aR',state,x[0]).dot(O('aR',state,x[0])))/2
    M = csc_matrix(M)
    U = s.linalg.expm(M)
    return U


### Bosonic channels
# Lossy channel
def lossyChannel(state,x,g,n):
    # Defines Krauss operators for the lossy channel. The expression is based off arXiv:1708.05010v3 (eq 1.4)
    # state: State to act on
    # x: mode to act on
    # g: Attenuation of channel
    # n: Number of Krauss operators to compute
    
    L = []
    M = math.log(1-g)*O('n',state,x)/2
    M = M.todense()
    M = csc_matrix(M)
    E = s.linalg.expm(M)
    L.append(E)
    for j in range(1,n):
        E = (math.sqrt(g/(1-g))*O('aL',state,x)/math.sqrt(j)).dot(E)
        L.append(E)
        
    #print('Max value of last Krauss Operator:',np.max(np.abs(E.todense())))
    return L


def sparseP(M,i):
    # M: Sparse matrix
    # i: Power
    # Calculates the i'th power of a sparse matrix M
    out = s.identity(M.shape[1])
    for j in range(0,i):
        out = out.dot(M)
    return out
        
def kron(t):
    # t: Tuple of sparse matrices for which to compute the kronecker product
    # Computes the Kronecker product of a tuple of sparse matrices
    prod = t[0]
    for j in range(1,len(t)):
        prod = s.kron(prod,t[j])
    return prod

def kronP(O,n):
    # O: Sparse matrix
    # n: Power
    # Computes the n'th kronecker product power of the sparse matrix O
    if n>0:
        prod = O
        for j in range(1,n):
            prod = s.kron(prod,O)
    else:
        prod = 1
    return prod


def Mproduct(t):
    # t: Tuple of sparse matrices
    # Computes the product of the sparse matrices in the tuple t
    prod = t[0]
    for j in range(1,len(t)):
        if isinstance(t[j],(int,float)):
            prod = prod*t[j]
        else:
            prod = prod.dot(t[j])
    return prod

def herm(U):
    # U: Sparse matrix
    # Computes the Hermitian conjugate of the sparse matrix U
    U = np.conjugate(U)
    U = np.transpose(U)
    return U


def dotP(a,b):
    # a: Sparse matrix
    # b: Sparse matrix
    # Computes the inner (dot) product of two sparse matrices. 
    # If the dimensions do not match, the outer product (kronecker) is compute instead.
    [ra,ca] = a.shape()
    [rb,cb] = b.shape()
    if rb == ca:
        return a.dot(b)
    else:
        return kron((a,b))

                
def expectance(state,O):
    # O: Sparse matrix (Operator)
    # state: State object
    # Calculates the expectance value of operator O using the state
    M = state.matrix
    M = M.dot(O)
    return M.diagonal().sum()
